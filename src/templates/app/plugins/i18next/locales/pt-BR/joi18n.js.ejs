// https://github.com/ozum/joi18n/blob/master/locales/pt_BR.json
export const language = {
  root: 'value',
  key: '"{{!label}}" ',
  messages: {
    wrapArrays: true
  },
  any: {
    unknown: 'não é permitido',
    invalid: 'contém um valor inválido',
    empty: 'não aceita valor vazio',
    required: 'é obrigatório',
    allowOnly: 'deve ser idêntico ao campo anterior',
    default: 'ocorreu um erro ao executar o método padrão'
  },
  alternatives: {
    base: 'não corresponde a nenhuma altenativa válida',
    child: null
  },
  array: {
    base: 'deve ser uma matriz',
    includes: 'na posição {{pos}} não corresponde a nenhuma tipo válido',
    includesSingle: 'valor único de {{!label}} não corresponde a nenhuma tipo válido',
    includesOne: 'na posição {{pos}} falha, pois {{reason}}',
    includesOneSingle: 'valor único de {{!label}} falha, pois {{reason}}',
    includesRequiredUnknowns: 'não contém {{unknownMisses}} valor(es) obrigatório(s)',
    includesRequiredKnowns: 'não contém {{knownMisses}}',
    includesRequiredBoth: 'não contém {{knownMisses}} e {{unknownMisses}} outros valor(es) obrigatório(s)',
    excludes: 'na posição {{pos}} contém um valor excluído',
    excludesSingle: 'valor único de {{!label}} contém um valor excluído',
    hasKnown: 'does not contain at least one required match for type "{{!patternLabel}}"',
    hasUnknown: 'does not contain at least one required match',
    min: 'deve conter no mínimo {{limit}} itens',
    max: 'deve conter menos que ou igual a {{limit}} itens',
    length: 'deve conter {{limit}} itens',
    ordered: 'na posição {{pos}}  falha, pois {{reason}}',
    orderedLength: 'na posição {{pos}} falha, pois a matriz deve conter até {{limit}} itens',
    ref: 'referência a "{{ref}}" que não é um número inteiro positivo',
    sparse: 'não pode ser uma matriz esparsa',
    unique: 'na posição {{pos}} há um valor duplicado'
  },
  boolean: {
    base: 'deve ser boleano'
  },
  binary: {
    base: 'deve ser um buffer ou uma string',
    min: 'deve conter no mínimo {{limit}} bytes',
    max: 'deve conter no máximo {{limit}} bytes',
    length: 'deve conter {{limit}} bytes'
  },
  date: {
    base: 'deve ser um número em milisegundos ou uma data válida',
    strict: 'deve ser uma data válida',
    min: 'deve ser maior ou igual a {{limit}}',
    max: 'deve ser menor ou igual a {{limit}}',
    less: 'deve ser menor que "{{limit}}"',
    greater: 'deve ser maior que "{{limit}}"',
    isoDate: 'deve ser uma data no padrão ISO 8601',
    timestamp: {
      javascript: 'deve ser um timestamp válido ou um número de milissegundos',
      unix: 'deve ser um timestamp válido ou número de segundos'
    },
    ref: 'referência a {{ref}} que não é uma data'
  },
  function: {
    base: 'deve ser uma função',
    arity: 'deve ter um número de argumentos de {{n}}',
    minArity: 'deve ter um número de argumentos maior ou igual a {{n}}',
    maxArity: 'deve ter um número de argumentos menor ou igual a {{n}}',
    ref: 'deve ser uma referência Joi',
    class: 'deve ser uma classe'
  },
  lazy: {
    base: '!!erro de esquema: o esquema lazy deve ser configurado',
    schema: '!!erro de esquema: a função do esquema lazy deve retornar um esquema'
  },
  object: {
    base: 'deve ser um objeto',
    child: 'falha em {{!child}}, pois {{reason}}',
    min: 'deve conter no mínimo {{limit}} filho(s)',
    max: 'deve conter no máximo {{limit}} filho(s)',
    length: 'deve conter {{limit}} filho(s)',
    allowUnknown: '!!"{{!child}}" não é permitido',
    with: '!!"{{mainWithLabel}}" faltando o peer requerido "{{peerWithLabel}}"',
    without: '!!"{{mainWithLabel}}" conflito com pares proibidos "{{peerWithLabel}}"',
    missing: 'deve conter pelo menos um dos {{peersWithLabels}}',
    xor: 'contém um conflito entre pares exclusivos {{peersWithLabels}}',
    oxor: 'contém um conflito entre pares exclusivos opcionais {{peersWithLabels}}',
    and: 'contém {{presentWithLabels}} sem os seus pares necessários {{missingWithLabels}}',
    nand: '!!"{{mainWithLabel}}" não deve existir simultaneamente com {{peersWithLabels}}',
    assert: '!!"{{ref}}" validação falhou porque "{{ref}}" falhou para {{mensagem}}',
    rename: {
      multiple: 'não pôde renomear {{from}} pois muitas renomeaçãoes estão desativadas e já havia sido renomeado para {{to}}',
      override: 'não pôde renomear {{from}} pois sobrescrever está desabilitado e {{to}} já existe',
      regex: {
        multiple: 'não é possível renomear os filhos {{from}} porque várias renomeações estão desativadas e outra chave já foi renomeada para "{{to}}"',
        override: 'não pode renomear os filhos {{from}} porque a substituição está desabilitada e o alvo "{{to}}" existe'
      }
    },
    type: 'deve ser um instância de {{type}}',
    schema: 'deve ser uma instância Joi'
  },
  number: {
    base: 'deve ser um número',
    unsafe: 'must be a safe number',
    min: 'deve ser maior ou igual a {{limit}}',
    max: 'deve ser menor ou igual a {{limit}}',
    less: 'deve ser menor que {{limit}}',
    greater: 'deve ser maior que {{limit}}',
    integer: 'deve ser um inteiro',
    negative: 'deve ser um número negativo',
    positive: 'deve ser um número positivo',
    precision: 'não deve ter mais de {{limit}} casas decimais',
    ref: 'referências "{{ref}}" que não é um número',
    multiple: 'deve ser um múltiplo de {{multiple}}',
    port: 'deve ser uma porta válida'
  },
  string: {
    base: 'deve ser um texto',
    min: 'deve conter no mínimo {{limit}} caracteres',
    max: 'deve conter no máximo {{limit}} caracteres',
    length: 'deve conter {{limit}} caracteres',
    alphanum: 'deve conter apenas caracteres alpha-numéricos',
    token: 'deve conter apenas caracteres alpha-numéricos ou underscore "_"',
    regex: {
      base: 'com o valor "{{value}}" é inválido',
      name: 'com o valor "{{value}}" não corresponde ao padrão {{name}}',
      invert: {
        base: 'com valor "{{value}}" corresponde ao padrão invertido: {{pattern}}',
        name: 'com valor "{{value}}" corresponde ao padrão {{name}} invertido'
      }
    },
    email: 'deve ser um email válido',
    uri: 'deve ser um uri válido',
    uriRelativeOnly: 'deve ser um uri relativo válido',
    uriCustomScheme: 'deve ser um uri válido com um esquema que corresponda ao padrão {{scheme}}',
    isoDate: 'deve ser uma data ISO 8601 válida',
    guid: 'deve ser um GUID válido',
    hex: 'deve conter apenas caracteres hexadecimais',
    hexAlign: 'representação descodificada hexadecimal deve ser alinhada por byte',
    base64: 'deve ser uma string base64 válida',
    dataUri: 'deve ser uma string dataUri válida',
    hostname: 'deve ser um nome de host válido',
    normalize: 'deve ser unicode normalizado no formulário {{form}}',
    lowercase: 'deve conter apenas caracteres minúsculos',
    uppercase: 'deve conter apenas caracteres maiúsculos',
    trim: 'não deve ter espaço em branco à esquerda ou à direita',
    creditCard: 'deve ser um cartão de crédito',
    ref: 'referências" {{ref}} "que não é um número',
    ip: 'deve ser um endereço ip válido com um {{cidr}} CIDR',
    ipVersion: 'deve ser um endereço IP válido de uma das seguintes versões {{version}} com um {{cidr}} CIDR'
  },
  symbol: {
    base: 'deve ser um símbolo',
    map: 'deve ser um dos {{map}}'
  }
}
